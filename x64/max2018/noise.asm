; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24231.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??0Class_ID@@QEAA@KK@Z				; Class_ID::Class_ID
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??D@YA?AVPoint3@@MAEBV0@@Z			; operator*
PUBLIC	??D@YA?AVPoint3@@AEBV0@M@Z			; operator*
PUBLIC	??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ	; MaxSDK::AssetManagement::AssetId::AssetId
PUBLIC	?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z	; Noise::noise
PUBLIC	?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z	; Noise::noise
PUBLIC	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper
PUBLIC	?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z ; Noise::wood
PUBLIC	?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z	; Noise::wood
PUBLIC	?alterUVW@Noise@@SAXAEAVPoint3@@H@Z		; Noise::alterUVW
PUBLIC	?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::limitedNoise
PUBLIC	?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z ; Noise::limitedNoise
PUBLIC	?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z	; Fractal::f
PUBLIC	?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z	; Fractal::f
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f900000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@4049999a
PUBLIC	__real@40b00000
PUBLIC	__real@40e33333
PUBLIC	__real@4129999a
PUBLIC	__real@41700000
PUBLIC	__real@439d1127
PUBLIC	__real@b8d1b717
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__imp_cosf:PROC
EXTRN	__imp_sinf:PROC
EXTRN	__imp_sqrtf:PROC
EXTRN	__imp_??0Point3@@QEAA@MMM@Z:PROC
EXTRN	__imp_??0Point3@@QEAA@AEBV0@@Z:PROC
EXTRN	__imp_?Length@Point3@@QEBAMXZ:PROC
EXTRN	__imp_??YPoint3@@QEAAAEAV0@AEBV0@@Z:PROC
EXTRN	__imp_??XPoint3@@QEAAAEAV0@M@Z:PROC
EXTRN	__imp_??GPoint3@@QEBA?AV0@AEBV0@@Z:PROC
EXTRN	__imp_??HPoint3@@QEBA?AV0@AEBV0@@Z:PROC
EXTRN	__imp_?threshold@@YAMMMM@Z:PROC
EXTRN	?noise@Worley@@SAXQEANHPEANH@Z:PROC		; Worley::noise
EXTRN	?smooth@@YAMM@Z:PROC				; smooth
EXTRN	?smooth@@YAMMMM@Z:PROC				; smooth
EXTRN	?noise@Perlin@@SAMMM@Z:PROC			; Perlin::noise
EXTRN	?noise@Perlin@@SAMMMM@Z:PROC			; Perlin::noise
EXTRN	?noise@Perlin@@SAMMMMM@Z:PROC			; Perlin::noise
EXTRN	?snoise@Perlin@@SAMM@Z:PROC			; Perlin::snoise
EXTRN	?snoise@Perlin@@SAMMM@Z:PROC			; Perlin::snoise
EXTRN	?snoise@Perlin@@SAMMMM@Z:PROC			; Perlin::snoise
EXTRN	?snoise@Perlin@@SAMMMMM@Z:PROC			; Perlin::snoise
EXTRN	?fnoise2D@Perlin@@SAMMMM@Z:PROC			; Perlin::fnoise2D
EXTRN	?fnoise3D@Perlin@@SAMMMMM@Z:PROC		; Perlin::fnoise3D
EXTRN	?fnoise4D@Perlin@@SAMMMMMM@Z:PROC		; Perlin::fnoise4D
EXTRN	?fsnoise2D@Perlin@@SAMMMM@Z:PROC		; Perlin::fsnoise2D
EXTRN	?fsnoise3D@Perlin@@SAMMMMM@Z:PROC		; Perlin::fsnoise3D
EXTRN	?fsnoise4D@Perlin@@SAMMMMMM@Z:PROC		; Perlin::fsnoise4D
EXTRN	?fractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::fractal
EXTRN	?turbulence@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::turbulence
EXTRN	?fBm@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::fBm
EXTRN	?fBmTurb@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::fBmTurb
EXTRN	?heteroTerrain@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::heteroTerrain
EXTRN	?hybridMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::hybridMultiFractal
EXTRN	?ridgedMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::ridgedMultiFractal
EXTRN	?fractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::fractal
EXTRN	?turbulence@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::turbulence
EXTRN	?fBm@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::fBm
EXTRN	?fBmTurb@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::fBmTurb
EXTRN	?hybridMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::hybridMultiFractal
EXTRN	?ridgedMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::ridgedMultiFractal
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	GUID_NULL:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
?kTriObjNormalXTCID@@3VClass_ID@@B DQ 01H DUP (?)	; kTriObjNormalXTCID
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cos@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?cos@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sin@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?sin@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sqrt@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?sqrt@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D@YA?AVPoint3@@MAEBV0@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??D@YA?AVPoint3@@MAEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D@YA?AVPoint3@@AEBV0@M@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??D@YA?AVPoint3@@AEBV0@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ DD imagerel ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
	DD	imagerel ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ+21
	DD	imagerel $unwind$??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EkTriObjNormalXTCID@@YAXXZ DD imagerel ??__EkTriObjNormalXTCID@@YAXXZ
	DD	imagerel ??__EkTriObjNormalXTCID@@YAXXZ+32
	DD	imagerel $unwind$??__EkTriObjNormalXTCID@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN14
	DD	imagerel $LN14+364
	DD	imagerel $unwind$?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD imagerel $LN14
	DD	imagerel $LN14+420
	DD	imagerel $unwind$?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN18
	DD	imagerel $LN18+748
	DD	imagerel $unwind$?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z DD imagerel $LN15
	DD	imagerel $LN15+2009
	DD	imagerel $unwind$?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD imagerel $LN23
	DD	imagerel $LN23+2772
	DD	imagerel $unwind$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alterUVW@Noise@@SAXAEAVPoint3@@H@Z DD imagerel $LN7
	DD	imagerel $LN7+222
	DD	imagerel $unwind$?alterUVW@Noise@@SAXAEAVPoint3@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN6
	DD	imagerel $LN6+174
	DD	imagerel $unwind$?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z DD imagerel $LN8
	DD	imagerel $LN8+275
	DD	imagerel $unwind$?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN14
	DD	imagerel $LN14+544
	DD	imagerel $unwind$?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD imagerel $LN14
	DD	imagerel $LN14+612
	DD	imagerel $unwind$?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@b8d1b717
CONST	SEGMENT
__real@b8d1b717 DD 0b8d1b717r			; -0.0001
CONST	ENDS
;	COMDAT __real@439d1127
CONST	SEGMENT
__real@439d1127 DD 0439d1127r			; 314.134
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@4129999a
CONST	SEGMENT
__real@4129999a DD 04129999ar			; 10.6
CONST	ENDS
;	COMDAT __real@40e33333
CONST	SEGMENT
__real@40e33333 DD 040e33333r			; 7.1
CONST	ENDS
;	COMDAT __real@40b00000
CONST	SEGMENT
__real@40b00000 DD 040b00000r			; 5.5
CONST	ENDS
;	COMDAT __real@4049999a
CONST	SEGMENT
__real@4049999a DD 04049999ar			; 3.15
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f900000
CONST	SEGMENT
__real@3f900000 DD 03f900000r			; 1.125
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD 021701H
	DD	01f0117H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 021101H
	DD	01f0111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alterUVW@Noise@@SAXAEAVPoint3@@H@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD 042f19H
	DD	02d011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0158H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z DD 041801H
	DD	0190118H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD 011401H
	DD	0a214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EkTriObjNormalXTCID@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ DD 020701H
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D@YA?AVPoint3@@AEBV0@M@Z DD 011401H
	DD	06214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D@YA?AVPoint3@@MAEBV0@@Z DD 011401H
	DD	06214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?sqrt@@YAMM@Z DD imagerel ?sqrt@@YAMM@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?sqrt@@YAMM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?sqrt@@YAMM@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sqrt@@YAMM@Z DD 011319H
	DD	0620aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?sqrt@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?sin@@YAMM@Z DD imagerel ?sin@@YAMM@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?sin@@YAMM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?sin@@YAMM@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sin@@YAMM@Z DD 011319H
	DD	0620aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?sin@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?cos@@YAMM@Z DD imagerel ?cos@@YAMM@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?cos@@YAMM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?cos@@YAMM@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cos@@YAMM@Z DD 011319H
	DD	0620aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?cos@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?kTriObjNormalXTCID$initializer$@@3P6AXXZEA DQ FLAT:??__EkTriObjNormalXTCID@@YAXXZ ; kTriObjNormalXTCID$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\fractal.h
;	COMDAT ?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z
_TEXT	SEGMENT
tv65 = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
$T8 = 96
$T9 = 104
$T10 = 120
$T11 = 136
$T12 = 152
$T13 = 168
$T14 = 184
$T15 = 200
$T16 = 216
p$ = 256
d$ = 264
np$ = 272
?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z PROC	; Fractal::f, COMDAT

; 62   : 	static float f(Point3 p, float d, NoiseParams &np) {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 248				; 000000f8H

; 63   : 		switch (np.fractalFunction) {

	mov	rax, QWORD PTR np$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 7
	ja	$LN2@f
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN13@f[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@f:

; 64   : 			case 0: return (1.0f + Noise::noise(p, d, np)) * .5f;

	lea	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Noise::noise
	movss	xmm1, DWORD PTR __real@3f800000
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	jmp	$LN1@f
$LN5@f:

; 65   : 			case 1: return fractal(p, d, np);

	lea	rax, QWORD PTR $T10[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?fractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::fractal
	jmp	$LN1@f
$LN6@f:

; 66   : 			case 2: return turbulence(p, d, np);

	lea	rax, QWORD PTR $T11[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?turbulence@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::turbulence
	jmp	$LN1@f
$LN7@f:

; 67   : 			case 3: return fBm(p, d, np);

	lea	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?fBm@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::fBm
	jmp	$LN1@f
$LN8@f:

; 68   : 			case 4: return fBmTurb(p, d, np);

	lea	rax, QWORD PTR $T13[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T5[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?fBmTurb@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::fBmTurb
	jmp	$LN1@f
$LN9@f:

; 69   : 			case 5: return heteroTerrain(p, np);

	lea	rax, QWORD PTR $T14[rsp]
	mov	QWORD PTR $T6[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?heteroTerrain@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::heteroTerrain
	jmp	SHORT $LN1@f
$LN10@f:

; 70   : 			case 6: return hybridMultiFractal(p, d, np);

	lea	rax, QWORD PTR $T15[rsp]
	mov	QWORD PTR $T7[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?hybridMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::hybridMultiFractal
	jmp	SHORT $LN1@f
$LN11@f:

; 71   : 			case 7: return ridgedMultiFractal(p, d, np);

	lea	rax, QWORD PTR $T16[rsp]
	mov	QWORD PTR $T8[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR d$[rsp]
	mov	rcx, rax
	call	?ridgedMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::ridgedMultiFractal
	jmp	SHORT $LN1@f
$LN2@f:

; 72   : 		}
; 73   : 		return 0.f;

	xorps	xmm0, xmm0
$LN1@f:

; 74   : 	}

	add	rsp, 248				; 000000f8H
	ret	0
	npad	1
$LN13@f:
	DD	$LN4@f
	DD	$LN5@f
	DD	$LN6@f
	DD	$LN7@f
	DD	$LN8@f
	DD	$LN9@f
	DD	$LN10@f
	DD	$LN11@f
?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ENDP	; Fractal::f
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\fractal.h
;	COMDAT ?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
tv65 = 32
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 72
$T6 = 80
$T7 = 88
$T8 = 96
$T9 = 104
$T10 = 120
$T11 = 136
$T12 = 152
$T13 = 168
$T14 = 184
$T15 = 200
$T16 = 216
p$ = 256
np$ = 264
?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC	; Fractal::f, COMDAT

; 48   : 	static float f(Point3 p, NoiseParams &np) {

$LN14:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 248				; 000000f8H

; 49   : 		switch (np.fractalFunction) {

	mov	rax, QWORD PTR np$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 7
	ja	$LN2@f
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN13@f[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@f:

; 50   : 			case 0: return (1.0f + Noise::noise(p, np)) * .5f;

	lea	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::noise
	movss	xmm1, DWORD PTR __real@3f800000
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	jmp	$LN1@f
$LN5@f:

; 51   : 			case 1: return fractal(p, np);

	lea	rax, QWORD PTR $T10[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?fractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::fractal
	jmp	$LN1@f
$LN6@f:

; 52   : 			case 2: return turbulence(p, np);

	lea	rax, QWORD PTR $T11[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?turbulence@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::turbulence
	jmp	$LN1@f
$LN7@f:

; 53   : 			case 3: return fBm(p, np);

	lea	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?fBm@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::fBm
	jmp	$LN1@f
$LN8@f:

; 54   : 			case 4: return fBmTurb(p, np);

	lea	rax, QWORD PTR $T13[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T5[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?fBmTurb@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::fBmTurb
	jmp	$LN1@f
$LN9@f:

; 55   : 			case 5: return heteroTerrain(p, np);

	lea	rax, QWORD PTR $T14[rsp]
	mov	QWORD PTR $T6[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?heteroTerrain@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::heteroTerrain
	jmp	SHORT $LN1@f
$LN10@f:

; 56   : 			case 6: return hybridMultiFractal(p, np);

	lea	rax, QWORD PTR $T15[rsp]
	mov	QWORD PTR $T7[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?hybridMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::hybridMultiFractal
	jmp	SHORT $LN1@f
$LN11@f:

; 57   : 			case 7: return ridgedMultiFractal(p, np);

	lea	rax, QWORD PTR $T16[rsp]
	mov	QWORD PTR $T8[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?ridgedMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::ridgedMultiFractal
	jmp	SHORT $LN1@f
$LN2@f:

; 58   : 		}
; 59   : 		return 0.f;

	xorps	xmm0, xmm0
$LN1@f:

; 60   : 	}

	add	rsp, 248				; 000000f8H
	ret	0
	npad	2
$LN13@f:
	DD	$LN4@f
	DD	$LN5@f
	DD	$LN6@f
	DD	$LN7@f
	DD	$LN8@f
	DD	$LN9@f
	DD	$LN10@f
	DD	$LN11@f
?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP	; Fractal::f
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z
_TEXT	SEGMENT
res$ = 32
lx$ = 36
ly$ = 40
tv69 = 44
$T1 = 48
$T2 = 56
p$ = 96
dpdx$ = 104
dpdy$ = 112
np$ = 120
?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z PROC ; Noise::limitedNoise, COMDAT

; 211  : float Noise::limitedNoise(Point3 p, Point3 dpdx, Point3 dpdy, NoiseParams &np) {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 212  : 	float lx = dpdx.Length();

	mov	rcx, QWORD PTR dpdx$[rsp]
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ
	movss	DWORD PTR lx$[rsp], xmm0

; 213  : 	float ly = dpdy.Length();

	mov	rcx, QWORD PTR dpdy$[rsp]
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ
	movss	DWORD PTR ly$[rsp], xmm0

; 214  : 	lx = MAX(lx, ly);

	movss	xmm0, DWORD PTR lx$[rsp]
	comiss	xmm0, DWORD PTR ly$[rsp]
	jbe	SHORT $LN6@limitedNoi
	movss	xmm0, DWORD PTR lx$[rsp]
	movss	DWORD PTR tv69[rsp], xmm0
	jmp	SHORT $LN7@limitedNoi
$LN6@limitedNoi:
	movss	xmm0, DWORD PTR ly$[rsp]
	movss	DWORD PTR tv69[rsp], xmm0
$LN7@limitedNoi:
	movss	xmm0, DWORD PTR tv69[rsp]
	movss	DWORD PTR lx$[rsp], xmm0

; 215  : 	float res = Fractal::f(p, lx, np);	

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r8, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR lx$[rsp]
	mov	rcx, rax
	call	?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::f
	movss	DWORD PTR res$[rsp], xmm0

; 216  : 	if (np.low<np.high) res = threshold(res,np.low,np.high);		

	mov	rax, QWORD PTR np$[rsp]
	mov	rcx, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	comiss	xmm0, DWORD PTR [rcx+60]
	jbe	SHORT $LN2@limitedNoi
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm2, DWORD PTR [rax+64]
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR [rax+60]
	movss	xmm0, DWORD PTR res$[rsp]
	call	QWORD PTR __imp_?threshold@@YAMMMM@Z
	movss	DWORD PTR res$[rsp], xmm0
$LN2@limitedNoi:

; 217  : 	if (res < 0) return 0.0f;

	movss	xmm0, DWORD PTR res$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jae	SHORT $LN3@limitedNoi
	xorps	xmm0, xmm0
	jmp	SHORT $LN1@limitedNoi
$LN3@limitedNoi:

; 218  : 	if (res > 1) return 1.0f;

	movss	xmm0, DWORD PTR res$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN4@limitedNoi
	movss	xmm0, DWORD PTR __real@3f800000
	jmp	SHORT $LN1@limitedNoi
$LN4@limitedNoi:

; 219  : 	return res;

	movss	xmm0, DWORD PTR res$[rsp]
$LN1@limitedNoi:

; 220  : }

	add	rsp, 88					; 00000058H
	ret	0
?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z ENDP ; Noise::limitedNoise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
res$ = 32
$T1 = 40
$T2 = 48
p$ = 80
np$ = 88
?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC ; Noise::limitedNoise, COMDAT

; 203  : float Noise::limitedNoise(Point3 p, NoiseParams &np) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 204  : 	float res = Fractal::f(p, np);	

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::f
	movss	DWORD PTR res$[rsp], xmm0

; 205  : 	if (np.low<np.high) res = threshold(res,np.low,np.high);		

	mov	rax, QWORD PTR np$[rsp]
	mov	rcx, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR [rax+64]
	comiss	xmm0, DWORD PTR [rcx+60]
	jbe	SHORT $LN2@limitedNoi
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm2, DWORD PTR [rax+64]
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm1, DWORD PTR [rax+60]
	movss	xmm0, DWORD PTR res$[rsp]
	call	QWORD PTR __imp_?threshold@@YAMMMM@Z
	movss	DWORD PTR res$[rsp], xmm0
$LN2@limitedNoi:

; 206  : 	if (res < 0) return 0.0f;

	movss	xmm0, DWORD PTR res$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jae	SHORT $LN3@limitedNoi
	xorps	xmm0, xmm0
	jmp	SHORT $LN1@limitedNoi
$LN3@limitedNoi:

; 207  : 	if (res > 1) return 1.0f;

	movss	xmm0, DWORD PTR res$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN4@limitedNoi
	movss	xmm0, DWORD PTR __real@3f800000
	jmp	SHORT $LN1@limitedNoi
$LN4@limitedNoi:

; 208  : 	return res;

	movss	xmm0, DWORD PTR res$[rsp]
$LN1@limitedNoi:

; 209  : }

	add	rsp, 72					; 00000048H
	ret	0
?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP ; Noise::limitedNoise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?alterUVW@Noise@@SAXAEAVPoint3@@H@Z
_TEXT	SEGMENT
tv64 = 32
p$ = 64
type$ = 72
?alterUVW@Noise@@SAXAEAVPoint3@@H@Z PROC		; Noise::alterUVW, COMDAT

; 21   : void Noise::alterUVW(Point3& p, int type) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 22   : 	switch (type) {

	mov	eax, DWORD PTR type$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 1
	je	SHORT $LN4@alterUVW
	cmp	DWORD PTR tv64[rsp], 2
	je	SHORT $LN5@alterUVW
	jmp	$LN2@alterUVW
$LN4@alterUVW:

; 23   : 		case 1: 
; 24   : 			p.x = sqrt(p.x * p.x + p.y * p.y);

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	call	?sqrt@@YAMM@Z				; sqrt
	mov	rax, QWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0

; 25   : 			p.y = 0.f;

	mov	rax, QWORD PTR p$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 26   : 			break;

	jmp	SHORT $LN2@alterUVW
$LN5@alterUVW:

; 27   : 		case 2:	
; 28   : 			p.x = sqrt(p.x * p.x + p.y * p.y + p.z * p.z);

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	call	?sqrt@@YAMM@Z				; sqrt
	mov	rax, QWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0

; 29   : 			p.y = 0.f;			

	mov	rax, QWORD PTR p$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0

; 30   : 			p.z = 0.f;

	mov	rax, QWORD PTR p$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0
$LN2@alterUVW:

; 31   : 			break;
; 32   : 	}
; 33   : }

	add	rsp, 56					; 00000038H
	ret	0
?alterUVW@Noise@@SAXAEAVPoint3@@H@Z ENDP		; Noise::alterUVW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
_TEXT	SEGMENT
dist$1 = 48
filter$ = 52
d$2 = 56
j$3 = 60
i$4 = 64
tv276 = 68
total$ = 72
lx$ = 76
ly$ = 80
tv69 = 84
angle$ = 88
samplesf$ = 92
tv321 = 96
ipart$5 = 100
tv84 = 104
tv140 = 108
tv160 = 112
tv178 = 116
tv184 = 120
tv169 = 124
tv221 = 128
angNoise$ = 132
gain$6 = 136
tv200 = 144
tv239 = 152
tv264 = 160
$T7 = 168
$T8 = 180
$T9 = 192
$T10 = 204
$T11 = 216
$T12 = 228
$T13 = 240
$T14 = 252
$T15 = 264
$T16 = 276
$T17 = 288
$T18 = 300
$T19 = 312
fp$ = 328
__$ArrayPad$ = 344
p$ = 384
dPdx$ = 392
dPdy$ = 400
g$ = 408
wp$ = 416
?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z PROC	; Noise::wood, COMDAT

; 143  : float Noise::wood(Point3 p, Point3 dPdx, Point3 dPdy, Point3 &g, WoodParam wp) {

$LN23:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 360				; 00000168H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 144  : 	// Filtered noises are only intrested in maximum change in X, Y and Z axis.
; 145  : 	float lx = dPdx.Length();

	mov	rcx, QWORD PTR dPdx$[rsp]
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ
	movss	DWORD PTR lx$[rsp], xmm0

; 146  : 	float ly = dPdy.Length();

	mov	rcx, QWORD PTR dPdy$[rsp]
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ
	movss	DWORD PTR ly$[rsp], xmm0

; 147  : 	float filter = MAX(lx, ly);

	movss	xmm0, DWORD PTR lx$[rsp]
	comiss	xmm0, DWORD PTR ly$[rsp]
	jbe	SHORT $LN19@wood
	movss	xmm0, DWORD PTR lx$[rsp]
	movss	DWORD PTR tv69[rsp], xmm0
	jmp	SHORT $LN20@wood
$LN19@wood:
	movss	xmm0, DWORD PTR ly$[rsp]
	movss	DWORD PTR tv69[rsp], xmm0
$LN20@wood:
	movss	xmm0, DWORD PTR tv69[rsp]
	movss	DWORD PTR filter$[rsp], xmm0

; 148  : 	// Radial noise
; 149  : 	p.x += Perlin::fsnoise4D(p.x*wp.radialFreq, p.y*wp.radialFreq, p.z*wp.radialZ, wp.randSeed-1.125f, filter*wp.radialFreq) * wp.radialStr;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR filter$[rsp]
	mulss	xmm0, DWORD PTR [rax+44]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR __real@3f900000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm3, DWORD PTR [rax+4]
	mulss	xmm3, DWORD PTR [rcx+44]
	movss	DWORD PTR tv84[rsp], xmm3
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm4, DWORD PTR [rax]
	mulss	xmm4, DWORD PTR [rcx+44]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv84[rsp]
	movaps	xmm1, xmm0
	movaps	xmm0, xmm4
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0

; 150  : 	p.y += Perlin::fsnoise4D(p.x*wp.radialFreq, p.y*wp.radialFreq, p.z*wp.radialZ, wp.randSeed+1.125f, filter*wp.radialFreq) * wp.radialStr;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR filter$[rsp]
	mulss	xmm0, DWORD PTR [rax+44]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR __real@3f900000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm3, DWORD PTR [rax+4]
	mulss	xmm3, DWORD PTR [rcx+44]
	movss	DWORD PTR tv140[rsp], xmm3
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm4, DWORD PTR [rax]
	mulss	xmm4, DWORD PTR [rcx+44]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv140[rsp]
	movaps	xmm1, xmm0
	movaps	xmm0, xmm4
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 151  : 	g = p; // Store radial component for gain

	mov	rdi, QWORD PTR g$[rsp]
	mov	rsi, QWORD PTR p$[rsp]
	mov	ecx, 12
	rep movsb

; 152  : 	// Trunk wobble		
; 153  : 	float angle = Perlin::fsnoise2D(p.z*wp.trunkFreq, wp.randSeed+3.f, filter*wp.trunkFreq) * (float)pi;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR filter$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR __real@40400000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, DWORD PTR [rcx+36]
	movss	DWORD PTR tv160[rsp], xmm2
	movaps	xmm2, xmm0
	movss	xmm0, DWORD PTR tv160[rsp]
	call	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
	mulss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR angle$[rsp], xmm0

; 154  : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::fsnoise2D(p.z*wp.trunkFreq, wp.randSeed-5.5f, filter*wp.trunkFreq) * wp.trunkStr;		

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR filter$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR __real@40b00000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, DWORD PTR [rcx+36]
	movss	DWORD PTR tv178[rsp], xmm2
	movaps	xmm2, xmm0
	movss	xmm0, DWORD PTR tv178[rsp]
	call	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
	movss	DWORD PTR tv169[rsp], xmm0
	movss	xmm0, DWORD PTR angle$[rsp]
	call	?sin@@YAMM@Z				; sin
	movss	DWORD PTR tv184[rsp], xmm0
	movss	xmm0, DWORD PTR angle$[rsp]
	call	?cos@@YAMM@Z				; cos
	xorps	xmm3, xmm3
	movss	xmm1, DWORD PTR tv184[rsp]
	movaps	xmm2, xmm1
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T7[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	movss	xmm0, DWORD PTR tv169[rsp]
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rcx+32]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	rdx, rax
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??YPoint3@@QEAAAEAV0@AEBV0@@Z

; 155  : 	g = .5f*g + .5f*p; // We don't want trunk wobble to affect too much to grain

	mov	r8, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T10[rsp]
	call	??D@YA?AVPoint3@@MAEBV0@@Z		; operator*
	mov	QWORD PTR tv200[rsp], rax
	mov	r8, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T11[rsp]
	call	??D@YA?AVPoint3@@MAEBV0@@Z		; operator*
	mov	rcx, QWORD PTR tv200[rsp]
	mov	r8, rcx
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_??HPoint3@@QEBA?AV0@AEBV0@@Z
	mov	rdi, QWORD PTR g$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb

; 156  : 	// Angular noise (applied inside super sampled code, but not dependant on it)
; 157  : 	float angNoise = Perlin::fnoise4D(p.x*wp.angleFreq, p.y*wp.angleFreq, p.z*wp.angleFreq*.5f, wp.randSeed+10.6f, filter*wp.angleFreq);	

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR filter$[rsp]
	mulss	xmm0, DWORD PTR [rax+56]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR __real@4129999a
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, DWORD PTR [rcx+56]
	mulss	xmm2, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm3, DWORD PTR [rax+4]
	mulss	xmm3, DWORD PTR [rcx+56]
	movss	DWORD PTR tv221[rsp], xmm3
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm4, DWORD PTR [rax]
	mulss	xmm4, DWORD PTR [rcx+56]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm3, xmm1
	movss	xmm0, DWORD PTR tv221[rsp]
	movaps	xmm1, xmm0
	movaps	xmm0, xmm4
	call	?fnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fnoise4D
	movss	DWORD PTR angNoise$[rsp], xmm0

; 158  : 	// Super sampling the mod function and functions dependant on it starts here
; 159  : 	float samplesf = (float)wp.samples;

	mov	rax, QWORD PTR wp$[rsp]
	cvtsi2ss xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR samplesf$[rsp], xmm0

; 160  : 	float total = 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR total$[rsp], xmm0

; 161  : 	Point3 fp = p - dPdx * .5f - dPdy * .5f;

	movss	xmm2, DWORD PTR __real@3f000000
	mov	rdx, QWORD PTR dPdy$[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	QWORD PTR tv239[rsp], rax
	movss	xmm2, DWORD PTR __real@3f000000
	mov	rdx, QWORD PTR dPdx$[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR $T15[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??GPoint3@@QEBA?AV0@AEBV0@@Z
	mov	rcx, QWORD PTR tv239[rsp]
	mov	r8, rcx
	lea	rdx, QWORD PTR fp$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_??GPoint3@@QEBA?AV0@AEBV0@@Z

; 162  : 	for (int i=0; i<wp.samples; i++) for (int j=0; j<wp.samples; j++) {

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN4@wood
$LN2@wood:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN4@wood:
	mov	rax, QWORD PTR wp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$4[rsp], eax
	jge	$LN3@wood
	mov	DWORD PTR j$3[rsp], 0
	jmp	SHORT $LN7@wood
$LN5@wood:
	mov	eax, DWORD PTR j$3[rsp]
	inc	eax
	mov	DWORD PTR j$3[rsp], eax
$LN7@wood:
	mov	rax, QWORD PTR wp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR j$3[rsp], eax
	jge	$LN6@wood

; 163  : 		// Compute sample location
; 164  : 		p = fp + dPdx * (((float)i + .5f) / samplesf) + dPdy * (((float)j + .5f) / samplesf);

	cvtsi2ss xmm0, DWORD PTR j$3[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR samplesf$[rsp]
	movaps	xmm2, xmm0
	mov	rdx, QWORD PTR dPdy$[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	QWORD PTR tv264[rsp], rax
	cvtsi2ss xmm0, DWORD PTR i$4[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR samplesf$[rsp]
	movaps	xmm2, xmm0
	mov	rdx, QWORD PTR dPdx$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	r8, rax
	lea	rdx, QWORD PTR $T18[rsp]
	lea	rcx, QWORD PTR fp$[rsp]
	call	QWORD PTR __imp_??HPoint3@@QEBA?AV0@AEBV0@@Z
	mov	rcx, QWORD PTR tv264[rsp]
	mov	r8, rcx
	lea	rdx, QWORD PTR $T19[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_??HPoint3@@QEBA?AV0@AEBV0@@Z
	mov	rdi, QWORD PTR p$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb

; 165  : 		// Distance	
; 166  : 		float dist = 0.f;	

	xorps	xmm0, xmm0
	movss	DWORD PTR dist$1[rsp], xmm0

; 167  : 		switch (wp.woodType) {

	mov	rax, QWORD PTR wp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv276[rsp], eax
	cmp	DWORD PTR tv276[rsp], 0
	je	SHORT $LN10@wood
	cmp	DWORD PTR tv276[rsp], 1
	je	SHORT $LN11@wood
	cmp	DWORD PTR tv276[rsp], 2
	je	$LN12@wood
	cmp	DWORD PTR tv276[rsp], 3
	je	$LN13@wood
	jmp	$LN8@wood
$LN10@wood:

; 168  : 			case 0: dist = sqrt(p.x*p.x+p.y*p.y); break;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	call	?sqrt@@YAMM@Z				; sqrt
	movss	DWORD PTR dist$1[rsp], xmm0
	jmp	$LN8@wood
$LN11@wood:

; 169  : 			case 1: p*=.05f; dist = (Perlin::noise(p.x, p.y, p.z, wp.randSeed-7.1f)+1.f) / .5f * 15.f; break;

	movss	xmm1, DWORD PTR __real@3d4ccccd
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??XPoint3@@QEAAAEAV0@M@Z
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@40e33333
	movaps	xmm3, xmm0
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	addss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR dist$1[rsp], xmm0
	jmp	$LN8@wood
$LN12@wood:

; 170  : 			case 2: p*=.05f; dist = (Perlin::snoise(p.x, p.y, p.z, wp.randSeed+3.15f)+1.f) / .5f * 15.f; break;

	movss	xmm1, DWORD PTR __real@3d4ccccd
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??XPoint3@@QEAAAEAV0@M@Z
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@4049999a
	movaps	xmm3, xmm0
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	addss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR dist$1[rsp], xmm0
	jmp	SHORT $LN8@wood
$LN13@wood:

; 171  : 			case 3: dist = p.x<0.f?-p.x:p.x; break;

	mov	rax, QWORD PTR p$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	jbe	SHORT $LN21@wood
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv321[rsp], xmm0
	jmp	SHORT $LN22@wood
$LN21@wood:
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv321[rsp], xmm0
$LN22@wood:
	movss	xmm0, DWORD PTR tv321[rsp]
	movss	DWORD PTR dist$1[rsp], xmm0
$LN8@wood:

; 172  : 		}
; 173  : 		// Width variation
; 174  : 		dist += Perlin::snoise(dist+wp.randSeed*2.f) * wp.widthVar; // We need FAST and continous random function here, 1D Simplex does fairly well

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR dist$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+24]
	movss	xmm1, DWORD PTR dist$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$1[rsp], xmm0

; 175  : 		// Angular noise
; 176  : 		float d = dist;

	movss	xmm0, DWORD PTR dist$1[rsp]
	movss	DWORD PTR d$2[rsp], xmm0

; 177  : 		if (d > wp.angleRad) d = wp.angleRad;	

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR d$2[rsp]
	comiss	xmm0, DWORD PTR [rax+60]
	jbe	SHORT $LN14@wood
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR d$2[rsp], xmm0
$LN14@wood:

; 178  : 		dist += SMOOTH(d/wp.angleRad) * angNoise * wp.angleStr;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR d$2[rsp]
	divss	xmm0, DWORD PTR [rax+60]
	mulss	xmm0, DWORD PTR d$2[rsp]
	mov	rax, QWORD PTR wp$[rsp]
	divss	xmm0, DWORD PTR [rax+60]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR d$2[rsp]
	mov	rax, QWORD PTR wp$[rsp]
	divss	xmm1, DWORD PTR [rax+60]
	movss	xmm2, DWORD PTR __real@40400000
	subss	xmm2, xmm1
	movaps	xmm1, xmm2
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR angNoise$[rsp]
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+52]
	movss	xmm1, DWORD PTR dist$1[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$1[rsp], xmm0

; 179  : 		// Mod
; 180  : 		float ipart = (float)(int)dist;		

	cvttss2si eax, DWORD PTR dist$1[rsp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR ipart$5[rsp], xmm0

; 181  : 		dist -= ipart;

	movss	xmm0, DWORD PTR dist$1[rsp]
	subss	xmm0, DWORD PTR ipart$5[rsp]
	movss	DWORD PTR dist$1[rsp], xmm0

; 182  : 		// Skew
; 183  : 		if (dist < wp.skew)

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR dist$1[rsp]
	comiss	xmm0, DWORD PTR [rax+20]
	jae	SHORT $LN15@wood

; 184  : 			dist *= .5f / wp.skew;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR [rax+20]
	movss	xmm1, DWORD PTR dist$1[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$1[rsp], xmm0

; 185  : 		else

	jmp	SHORT $LN16@wood
$LN15@wood:

; 186  : 			dist = dist * .5f / (1.f-wp.skew) - wp.skew * (.5f/(1.f-wp.skew)) + .5f;	

	movss	xmm0, DWORD PTR dist$1[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+20]
	divss	xmm0, xmm1
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+20]
	movss	xmm2, DWORD PTR __real@3f000000
	divss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+20]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dist$1[rsp], xmm0
$LN16@wood:

; 187  : 		// Reverse
; 188  : 		dist *= 2.f;

	movss	xmm0, DWORD PTR dist$1[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR dist$1[rsp], xmm0

; 189  : 		if (dist > 1.f)

	movss	xmm0, DWORD PTR dist$1[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN17@wood

; 190  : 			dist = 2.f - dist;

	movss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR dist$1[rsp]
	movss	DWORD PTR dist$1[rsp], xmm0
$LN17@wood:

; 191  : 		// Smooth and scale
; 192  : 		dist = smooth(dist, wp.lowTresh, wp.highTresh);	

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+16]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	movss	xmm0, DWORD PTR dist$1[rsp]
	call	?smooth@@YAMMMM@Z			; smooth
	movss	DWORD PTR dist$1[rsp], xmm0

; 193  : 		// Gain variation				
; 194  : 		float gain = (Perlin::snoise((ipart + wp.randSeed) * 314.134f) + 1.f) * .5f; // Again we need FAST random function, in this case it doesn't have to be continous		

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR ipart$5[rsp]
	addss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR __real@439d1127
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR gain$6[rsp], xmm0

; 195  : 		dist *= (1.f-wp.gainVar) + gain * wp.gainVar;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [rax+28]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR gain$6[rsp]
	mulss	xmm1, DWORD PTR [rax+28]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR dist$1[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$1[rsp], xmm0

; 196  : 		// Add to total value
; 197  : 	 	total += dist;

	movss	xmm0, DWORD PTR total$[rsp]
	addss	xmm0, DWORD PTR dist$1[rsp]
	movss	DWORD PTR total$[rsp], xmm0

; 198  : 	}

	jmp	$LN5@wood
$LN6@wood:
	jmp	$LN2@wood
$LN3@wood:

; 199  : 	// Return final value, just need to divide sum with number of samples taken
; 200  : 	return total / (float)(wp.samples * wp.samples);

	mov	rax, QWORD PTR wp$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	imul	eax, DWORD PTR [rcx+8]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR total$[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 201  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 360				; 00000168H
	pop	rdi
	pop	rsi
	ret	0
?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z ENDP	; Noise::wood
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z
_TEXT	SEGMENT
dist$ = 32
tv190 = 36
d$ = 40
angle$ = 44
tv235 = 48
ipart$ = 52
tv75 = 56
tv79 = 60
tv128 = 64
tv132 = 68
tv145 = 72
tv160 = 76
tv166 = 80
tv154 = 84
tv266 = 88
tv251 = 92
gain$ = 96
tv182 = 104
$T1 = 112
$T2 = 124
$T3 = 136
$T4 = 148
$T5 = 160
$T6 = 172
p$ = 224
g$ = 232
wp$ = 240
?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z PROC	; Noise::wood, COMDAT

; 87   : float Noise::wood(Point3 p, Point3 &g, WoodParam &wp) {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 88   : 	// Radial noise
; 89   : 	p.x += Perlin::snoise(p.x*wp.radialFreq, p.y*wp.radialFreq, p.z*wp.radialZ, wp.randSeed-1.125f) * wp.radialStr;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@3f900000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mulss	xmm2, DWORD PTR [rcx+44]
	movss	DWORD PTR tv75[rsp], xmm2
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm3, DWORD PTR [rax]
	mulss	xmm3, DWORD PTR [rcx+44]
	movss	DWORD PTR tv79[rsp], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv75[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv79[rsp]
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	movss	DWORD PTR [rax], xmm0

; 90   : 	p.y += Perlin::snoise(p.x*wp.radialFreq, p.y*wp.radialFreq, p.z*wp.radialZ, wp.randSeed+1.125f) * wp.radialStr;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@3f900000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+48]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mulss	xmm2, DWORD PTR [rcx+44]
	movss	DWORD PTR tv128[rsp], xmm2
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm3, DWORD PTR [rax]
	mulss	xmm3, DWORD PTR [rcx+44]
	movss	DWORD PTR tv132[rsp], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv128[rsp]
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv132[rsp]
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR p$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 91   : 	g = p; // Store radial component for gain

	mov	rdi, QWORD PTR g$[rsp]
	mov	rsi, QWORD PTR p$[rsp]
	mov	ecx, 12
	rep movsb

; 92   : 	// Trunk wobble		
; 93   : 	float angle = Perlin::snoise(p.z*wp.trunkFreq, wp.randSeed+3.f) * (float)pi; // Offset so we dont get the same value as below

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@40400000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+36]
	movss	DWORD PTR tv145[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv145[rsp]
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
	mulss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR angle$[rsp], xmm0

; 94   : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::snoise(p.z*wp.trunkFreq, wp.randSeed-5.5f) * wp.trunkStr;		

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@40b00000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+36]
	movss	DWORD PTR tv160[rsp], xmm1
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv160[rsp]
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
	movss	DWORD PTR tv154[rsp], xmm0
	movss	xmm0, DWORD PTR angle$[rsp]
	call	?sin@@YAMM@Z				; sin
	movss	DWORD PTR tv166[rsp], xmm0
	movss	xmm0, DWORD PTR angle$[rsp]
	call	?cos@@YAMM@Z				; cos
	xorps	xmm3, xmm3
	movss	xmm1, DWORD PTR tv166[rsp]
	movaps	xmm2, xmm1
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	movss	xmm0, DWORD PTR tv154[rsp]
	movaps	xmm2, xmm0
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rcx+32]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??D@YA?AVPoint3@@AEBV0@M@Z		; operator*
	mov	rdx, rax
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??YPoint3@@QEAAAEAV0@AEBV0@@Z

; 95   : 	g = .5f*g + .5f*p; // We don't want trunk wobble to affect too much to grain

	mov	r8, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??D@YA?AVPoint3@@MAEBV0@@Z		; operator*
	mov	QWORD PTR tv182[rsp], rax
	mov	r8, QWORD PTR g$[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T5[rsp]
	call	??D@YA?AVPoint3@@MAEBV0@@Z		; operator*
	mov	rcx, QWORD PTR tv182[rsp]
	mov	r8, rcx
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_??HPoint3@@QEBA?AV0@AEBV0@@Z
	mov	rdi, QWORD PTR g$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb

; 96   : 	// Distance
; 97   : 	float dist = 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR dist$[rsp], xmm0

; 98   : 	switch (wp.woodType) {

	mov	rax, QWORD PTR wp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv190[rsp], eax
	cmp	DWORD PTR tv190[rsp], 0
	je	SHORT $LN4@wood
	cmp	DWORD PTR tv190[rsp], 1
	je	SHORT $LN5@wood
	cmp	DWORD PTR tv190[rsp], 2
	je	$LN6@wood
	cmp	DWORD PTR tv190[rsp], 3
	je	$LN7@wood
	jmp	$LN2@wood
$LN4@wood:

; 99   : 		case 0: dist = sqrt(p.x*p.x+p.y*p.y); break;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	call	?sqrt@@YAMM@Z				; sqrt
	movss	DWORD PTR dist$[rsp], xmm0
	jmp	$LN2@wood
$LN5@wood:

; 100  : 		case 1: p*=.05f; dist = (Perlin::noise(p.x, p.y, p.z, wp.randSeed-7.1f)+1.f) / .5f * 15.f; break;

	movss	xmm1, DWORD PTR __real@3d4ccccd
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??XPoint3@@QEAAAEAV0@M@Z
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR __real@40e33333
	movaps	xmm3, xmm0
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	addss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR dist$[rsp], xmm0
	jmp	$LN2@wood
$LN6@wood:

; 101  : 		case 2: p*=.05f; dist = (Perlin::snoise(p.x, p.y, p.z, wp.randSeed+3.15f)+1.f) / .5f * 15.f; break;

	movss	xmm1, DWORD PTR __real@3d4ccccd
	mov	rcx, QWORD PTR p$[rsp]
	call	QWORD PTR __imp_??XPoint3@@QEAAAEAV0@M@Z
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR __real@4049999a
	movaps	xmm3, xmm0
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	addss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR dist$[rsp], xmm0
	jmp	SHORT $LN2@wood
$LN7@wood:

; 102  : 		case 3: dist = p.x<0.f?-p.x:p.x; break;

	mov	rax, QWORD PTR p$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	jbe	SHORT $LN13@wood
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv235[rsp], xmm0
	jmp	SHORT $LN14@wood
$LN13@wood:
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR tv235[rsp], xmm0
$LN14@wood:
	movss	xmm0, DWORD PTR tv235[rsp]
	movss	DWORD PTR dist$[rsp], xmm0
$LN2@wood:

; 103  : 	}
; 104  : 	// Width variation
; 105  : 	dist += Perlin::snoise(dist+wp.randSeed*2.f) * wp.widthVar;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR dist$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+24]
	movss	xmm1, DWORD PTR dist$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$[rsp], xmm0

; 106  : 	// Angular noise
; 107  : 	float d = dist;

	movss	xmm0, DWORD PTR dist$[rsp]
	movss	DWORD PTR d$[rsp], xmm0

; 108  : 	if (d > wp.angleRad) d = wp.angleRad;	

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR d$[rsp]
	comiss	xmm0, DWORD PTR [rax+60]
	jbe	SHORT $LN8@wood
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR [rax+60]
	movss	DWORD PTR d$[rsp], xmm0
$LN8@wood:

; 109  : 	dist += smooth(d/wp.angleRad) * Perlin::noise(p.x*wp.angleFreq, p.y*wp.angleFreq, p.z*wp.angleFreq*.5f, wp.randSeed+10.6f) * wp.angleStr;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR d$[rsp]
	divss	xmm0, DWORD PTR [rax+60]
	call	?smooth@@YAMM@Z				; smooth
	movss	DWORD PTR tv251[rsp], xmm0
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR __real@4129999a
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mulss	xmm2, DWORD PTR [rcx+56]
	mulss	xmm2, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm3, DWORD PTR [rax+4]
	mulss	xmm3, DWORD PTR [rcx+56]
	movss	DWORD PTR tv266[rsp], xmm3
	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR wp$[rsp]
	movss	xmm4, DWORD PTR [rax]
	mulss	xmm4, DWORD PTR [rcx+56]
	movaps	xmm3, xmm1
	movss	xmm1, DWORD PTR tv266[rsp]
	movaps	xmm0, xmm4
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	movss	xmm1, DWORD PTR tv251[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR wp$[rsp]
	mulss	xmm0, DWORD PTR [rax+52]
	movss	xmm1, DWORD PTR dist$[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$[rsp], xmm0

; 110  : 	// Mod
; 111  : 	float ipart = (float)(int)dist;		

	cvttss2si eax, DWORD PTR dist$[rsp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR ipart$[rsp], xmm0

; 112  : 	dist -= ipart;

	movss	xmm0, DWORD PTR dist$[rsp]
	subss	xmm0, DWORD PTR ipart$[rsp]
	movss	DWORD PTR dist$[rsp], xmm0

; 113  : 	// Skew
; 114  : 	if (dist < wp.skew)

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR dist$[rsp]
	comiss	xmm0, DWORD PTR [rax+20]
	jae	SHORT $LN9@wood

; 115  : 		dist *= .5f / wp.skew;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR [rax+20]
	movss	xmm1, DWORD PTR dist$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$[rsp], xmm0

; 116  : 	else

	jmp	SHORT $LN10@wood
$LN9@wood:

; 117  : 		dist = dist * .5f / (1.f-wp.skew) - wp.skew * (.5f/(1.f-wp.skew)) + .5f;	

	movss	xmm0, DWORD PTR dist$[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+20]
	divss	xmm0, xmm1
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+20]
	movss	xmm2, DWORD PTR __real@3f000000
	divss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+20]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR dist$[rsp], xmm0
$LN10@wood:

; 118  : 	// Reverse
; 119  : 	dist *= 2.f;

	movss	xmm0, DWORD PTR dist$[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR dist$[rsp], xmm0

; 120  : 	if (dist > 1.f)

	movss	xmm0, DWORD PTR dist$[rsp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN11@wood

; 121  : 		dist = 2.f-dist;

	movss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR dist$[rsp]
	movss	DWORD PTR dist$[rsp], xmm0
$LN11@wood:

; 122  : 	// Smooth and scale
; 123  : 	dist = smooth(dist, wp.lowTresh, wp.highTresh);	

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm2, DWORD PTR [rax+16]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	movss	xmm0, DWORD PTR dist$[rsp]
	call	?smooth@@YAMMMM@Z			; smooth
	movss	DWORD PTR dist$[rsp], xmm0

; 124  : 	// Gain variation		
; 125  : 	float gain = (Perlin::snoise((ipart + wp.randSeed) * 314.134f) + 1.f) * .5f;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR ipart$[rsp]
	addss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR __real@439d1127
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR gain$[rsp], xmm0

; 126  : 	dist *= (1.f-wp.gainVar) + gain * wp.gainVar;

	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [rax+28]
	mov	rax, QWORD PTR wp$[rsp]
	movss	xmm1, DWORD PTR gain$[rsp]
	mulss	xmm1, DWORD PTR [rax+28]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR dist$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR dist$[rsp], xmm0

; 127  : 	// Return	
; 128  : 	return dist;

	movss	xmm0, DWORD PTR dist$[rsp]

; 129  : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z ENDP	; Noise::wood
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
val$ = 32
order$ = 36
tv87 = 40
f$ = 48
p3$ = 80
__$ArrayPad$ = 104
p$ = 128
np$ = 136
?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC ; Noise::worleyWrapper, COMDAT

; 61   : float Noise::worleyWrapper(Point3 p, NoiseParams& np) {	

$LN18:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 62   : 	float val;
; 63   : 	double p3[3] = {(double)p.x, (double)p.y, (double)p.z};

	mov	rax, QWORD PTR p$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax]
	movsd	QWORD PTR p3$[rsp], xmm0
	mov	rax, QWORD PTR p$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+4]
	movsd	QWORD PTR p3$[rsp+8], xmm0
	mov	rax, QWORD PTR p$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+8]
	movsd	QWORD PTR p3$[rsp+16], xmm0

; 64   : 	double f[4];
; 65   : 	int order = 1;

	mov	DWORD PTR order$[rsp], 1

; 66   : 	// Calc order
; 67   : 	if (np.F4 > 0.0001f || np.F4 < -0.0001f)

	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR __real@38d1b717
	comiss	xmm0, DWORD PTR [rax+32]
	jb	SHORT $LN6@worleyWrap
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR __real@b8d1b717
	comiss	xmm0, DWORD PTR [rax+32]
	jbe	SHORT $LN4@worleyWrap
$LN6@worleyWrap:

; 68   : 		order = 4;

	mov	DWORD PTR order$[rsp], 4
	jmp	SHORT $LN5@worleyWrap
$LN4@worleyWrap:

; 69   : 	else if (np.F3 > 0.0001f || np.F3 < -0.0001f)

	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR __real@38d1b717
	comiss	xmm0, DWORD PTR [rax+28]
	jb	SHORT $LN9@worleyWrap
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR __real@b8d1b717
	comiss	xmm0, DWORD PTR [rax+28]
	jbe	SHORT $LN7@worleyWrap
$LN9@worleyWrap:

; 70   : 		order = 3;

	mov	DWORD PTR order$[rsp], 3
	jmp	SHORT $LN8@worleyWrap
$LN7@worleyWrap:

; 71   : 	else if (np.F2 > 0.0001f || np.F2 < -0.0001f)

	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR __real@38d1b717
	comiss	xmm0, DWORD PTR [rax+24]
	jb	SHORT $LN11@worleyWrap
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR __real@b8d1b717
	comiss	xmm0, DWORD PTR [rax+24]
	jbe	SHORT $LN10@worleyWrap
$LN11@worleyWrap:

; 72   : 		order = 2;

	mov	DWORD PTR order$[rsp], 2
$LN10@worleyWrap:
$LN8@worleyWrap:
$LN5@worleyWrap:

; 73   : 	// Worley
; 74   : 	Worley::noise(p3, order, f, np.worleyFunction);	

	mov	rax, QWORD PTR np$[rsp]
	mov	r9d, DWORD PTR [rax+8]
	lea	r8, QWORD PTR f$[rsp]
	mov	edx, DWORD PTR order$[rsp]
	lea	rcx, QWORD PTR p3$[rsp]
	call	?noise@Worley@@SAXQEANHPEANH@Z		; Worley::noise

; 75   : 	// Return value
; 76   : 	switch (order) {

	mov	eax, DWORD PTR order$[rsp]
	mov	DWORD PTR tv87[rsp], eax
	cmp	DWORD PTR tv87[rsp], 1
	je	SHORT $LN12@worleyWrap
	cmp	DWORD PTR tv87[rsp], 2
	je	SHORT $LN13@worleyWrap
	cmp	DWORD PTR tv87[rsp], 3
	je	SHORT $LN14@worleyWrap
	cmp	DWORD PTR tv87[rsp], 4
	je	$LN15@worleyWrap
	jmp	$LN16@worleyWrap
$LN12@worleyWrap:

; 77   : 		case 1: val = (float)f[0]*np.F1; break;

	mov	eax, 8
	imul	rax, rax, 0
	cvtsd2ss xmm0, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm0, DWORD PTR [rax+20]
	movss	DWORD PTR val$[rsp], xmm0
	jmp	$LN2@worleyWrap
$LN13@worleyWrap:

; 78   : 		case 2: val = (float)f[0]*np.F1 + (float)f[1]*np.F2; break;

	mov	eax, 8
	imul	rax, rax, 0
	cvtsd2ss xmm0, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm0, DWORD PTR [rax+20]
	mov	eax, 8
	imul	rax, rax, 1
	cvtsd2ss xmm1, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm1, DWORD PTR [rax+24]
	addss	xmm0, xmm1
	movss	DWORD PTR val$[rsp], xmm0
	jmp	$LN2@worleyWrap
$LN14@worleyWrap:

; 79   : 		case 3: val = (float)f[0]*np.F1 + (float)f[1]*np.F2 + (float)f[2]*np.F3; break;

	mov	eax, 8
	imul	rax, rax, 0
	cvtsd2ss xmm0, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm0, DWORD PTR [rax+20]
	mov	eax, 8
	imul	rax, rax, 1
	cvtsd2ss xmm1, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm1, DWORD PTR [rax+24]
	addss	xmm0, xmm1
	mov	eax, 8
	imul	rax, rax, 2
	cvtsd2ss xmm1, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm1, DWORD PTR [rax+28]
	addss	xmm0, xmm1
	movss	DWORD PTR val$[rsp], xmm0
	jmp	$LN2@worleyWrap
$LN15@worleyWrap:

; 80   : 		case 4: val = (float)f[0]*np.F1 + (float)f[1]*np.F2 + (float)f[2]*np.F3 + (float)f[3]*np.F4; break;

	mov	eax, 8
	imul	rax, rax, 0
	cvtsd2ss xmm0, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm0, DWORD PTR [rax+20]
	mov	eax, 8
	imul	rax, rax, 1
	cvtsd2ss xmm1, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm1, DWORD PTR [rax+24]
	addss	xmm0, xmm1
	mov	eax, 8
	imul	rax, rax, 2
	cvtsd2ss xmm1, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm1, DWORD PTR [rax+28]
	addss	xmm0, xmm1
	mov	eax, 8
	imul	rax, rax, 3
	cvtsd2ss xmm1, QWORD PTR f$[rsp+rax]
	mov	rax, QWORD PTR np$[rsp]
	mulss	xmm1, DWORD PTR [rax+32]
	addss	xmm0, xmm1
	movss	DWORD PTR val$[rsp], xmm0
	jmp	SHORT $LN2@worleyWrap
$LN16@worleyWrap:

; 81   : 		default: val = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR val$[rsp], xmm0
$LN2@worleyWrap:

; 82   : 	}
; 83   : 	val = val/np.spread*2.f-1.f;

	mov	rax, QWORD PTR np$[rsp]
	movss	xmm0, DWORD PTR val$[rsp]
	divss	xmm0, DWORD PTR [rax+16]
	mulss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR val$[rsp], xmm0

; 84   : 	return val;

	movss	xmm0, DWORD PTR val$[rsp]

; 85   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP ; Noise::worleyWrapper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z
_TEXT	SEGMENT
tv65 = 48
$T1 = 56
$T2 = 64
p$ = 96
d$ = 104
np$ = 112
?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z PROC	; Noise::noise, COMDAT

; 48   : float Noise::noise(Point3 p, float d, NoiseParams& np) {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 49   : 	switch (np.noiseFunction) {

	mov	rax, QWORD PTR np$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 6
	ja	$LN11@noise
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN13@noise[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@noise:

; 50   : 		case 0: return Perlin::fnoise2D(p.x, p.y, d);

	movss	xmm2, DWORD PTR d$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?fnoise2D@Perlin@@SAMMMM@Z		; Perlin::fnoise2D
	jmp	$LN1@noise
$LN5@noise:

; 51   : 		case 1: return Perlin::fnoise3D(p.x, p.y, p.z, d);

	movss	xmm3, DWORD PTR d$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?fnoise3D@Perlin@@SAMMMMM@Z		; Perlin::fnoise3D
	jmp	$LN1@noise
$LN6@noise:

; 52   : 		case 2: return Perlin::fnoise4D(p.x, p.y, p.z, np.phase, d);		

	movss	xmm0, DWORD PTR d$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?fnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fnoise4D
	jmp	$LN1@noise
$LN7@noise:

; 53   : 		case 3: return Perlin::fsnoise2D(p.x, p.y, d);

	movss	xmm2, DWORD PTR d$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
	jmp	$LN1@noise
$LN8@noise:

; 54   : 		case 4: return Perlin::fsnoise3D(p.x, p.y, p.z, d);

	movss	xmm3, DWORD PTR d$[rsp]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?fsnoise3D@Perlin@@SAMMMMM@Z		; Perlin::fsnoise3D
	jmp	SHORT $LN1@noise
$LN9@noise:

; 55   : 		case 5: return Perlin::fsnoise4D(p.x, p.y, p.z, np.phase, d);		

	movss	xmm0, DWORD PTR d$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rax, QWORD PTR np$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D
	jmp	SHORT $LN1@noise
$LN10@noise:

; 56   : 		case 6: return worleyWrapper(p, np);

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper
	jmp	SHORT $LN1@noise
$LN11@noise:

; 57   : 		default: return 0.0f;

	xorps	xmm0, xmm0
$LN1@noise:

; 58   : 	}
; 59   : }

	add	rsp, 88					; 00000058H
	ret	0
	npad	1
$LN13@noise:
	DD	$LN4@noise
	DD	$LN5@noise
	DD	$LN6@noise
	DD	$LN7@noise
	DD	$LN8@noise
	DD	$LN9@noise
	DD	$LN10@noise
?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z ENDP	; Noise::noise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
tv65 = 32
$T1 = 40
$T2 = 48
p$ = 80
np$ = 88
?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC	; Noise::noise, COMDAT

; 35   : float Noise::noise(Point3 p, NoiseParams& np) {

$LN14:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 36   : 	switch (np.noiseFunction) {

	mov	rax, QWORD PTR np$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 6
	ja	$LN11@noise
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN13@noise[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@noise:

; 37   : 		case 0: return Perlin::noise(p.x, p.y);

	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMM@Z			; Perlin::noise
	jmp	$LN1@noise
$LN5@noise:

; 38   : 		case 1: return Perlin::noise(p.x, p.y, p.z);

	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMMM@Z			; Perlin::noise
	jmp	$LN1@noise
$LN6@noise:

; 39   : 		case 2: return Perlin::noise(p.x, p.y, p.z, np.phase);		

	mov	rax, QWORD PTR np$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	jmp	$LN1@noise
$LN7@noise:

; 40   : 		case 3: return Perlin::snoise(p.x, p.y);

	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
	jmp	SHORT $LN1@noise
$LN8@noise:

; 41   : 		case 4: return Perlin::snoise(p.x, p.y, p.z);

	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMMM@Z		; Perlin::snoise
	jmp	SHORT $LN1@noise
$LN9@noise:

; 42   : 		case 5: return Perlin::snoise(p.x, p.y, p.z, np.phase);		

	mov	rax, QWORD PTR np$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm2, DWORD PTR [rax+8]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR p$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	jmp	SHORT $LN1@noise
$LN10@noise:

; 43   : 		case 6: return worleyWrapper(p, np);

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rdx, QWORD PTR np$[rsp]
	mov	rcx, rax
	call	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper
	jmp	SHORT $LN1@noise
$LN11@noise:

; 44   : 		default: return 0.0f;

	xorps	xmm0, xmm0
$LN1@noise:

; 45   : 	}
; 46   : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	2
$LN13@noise:
	DD	$LN4@noise
	DD	$LN5@noise
	DD	$LN6@noise
	DD	$LN7@noise
	DD	$LN8@noise
	DD	$LN9@noise
	DD	$LN10@noise
?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP	; Noise::noise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files\autodesk\3ds max 2018 sdk\maxsdk\include\triobj.h
;	COMDAT ??__EkTriObjNormalXTCID@@YAXXZ
text$di	SEGMENT
??__EkTriObjNormalXTCID@@YAXXZ PROC			; `dynamic initializer for 'kTriObjNormalXTCID'', COMDAT

; 289  : const Class_ID kTriObjNormalXTCID = Class_ID(0x730a33d7, 0x27246c55);

	sub	rsp, 40					; 00000028H
	mov	r8d, 656698453				; 27246c55H
	mov	edx, 1930048471				; 730a33d7H
	lea	rcx, OFFSET FLAT:?kTriObjNormalXTCID@@3VClass_ID@@B
	call	??0Class_ID@@QEAA@KK@Z			; Class_ID::Class_ID
	add	rsp, 40					; 00000028H
	ret	0
??__EkTriObjNormalXTCID@@YAXXZ ENDP			; `dynamic initializer for 'kTriObjNormalXTCID''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files\autodesk\3ds max 2018 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 32   : 		static AssetId kInvalidId;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A
	call	??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ; MaxSDK::AssetManagement::AssetId::AssetId
	add	rsp, 40					; 00000028H
	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files\autodesk\3ds max 2018 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 24
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	lea	rax, OFFSET FLAT:GUID_NULL
	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	pop	rsi
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files\autodesk\3ds max 2018 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@AEBV0@M@Z
_TEXT	SEGMENT
tv73 = 32
__$ReturnUdt$ = 64
a$ = 72
f$ = 80
??D@YA?AVPoint3@@AEBV0@M@Z PROC				; operator*, COMDAT

; 326  : __forceinline Point3 operator*(const Point3& a, float f) {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR f$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR f$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR f$[rsp]
	movss	DWORD PTR tv73[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv73[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 328  :    }

	add	rsp, 56					; 00000038H
	ret	0
??D@YA?AVPoint3@@AEBV0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files\autodesk\3ds max 2018 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@MAEBV0@@Z
_TEXT	SEGMENT
tv73 = 32
__$ReturnUdt$ = 64
f$ = 72
a$ = 80
??D@YA?AVPoint3@@MAEBV0@@Z PROC				; operator*, COMDAT

; 320  : __forceinline Point3 operator*(float f, const Point3& a) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	mov	rax, QWORD PTR a$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR f$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR f$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR f$[rsp]
	movss	DWORD PTR tv73[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv73[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 322  :    }

	add	rsp, 56					; 00000038H
	ret	0
??D@YA?AVPoint3@@MAEBV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
$T1 = 32
_Xx$ = 64
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 304  : 	{

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 305  : 	return (_CSTD sqrtf(_Xx));

	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	QWORD PTR __imp_sqrtf
	npad	1

; 306  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
$T1 = 32
_Xx$ = 64
?sin@@YAMM@Z PROC					; sin, COMDAT

; 294  : 	{

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 295  : 	return (_CSTD sinf(_Xx));

	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	QWORD PTR __imp_sinf
	npad	1

; 296  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
$T1 = 32
_Xx$ = 64
?cos@@YAMM@Z PROC					; cos, COMDAT

; 87   : 	{

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 88   : 	return (_CSTD cosf(_Xx));

	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	QWORD PTR __imp_cosf
	npad	1

; 89   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files\autodesk\3ds max 2018 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR aa$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bb$[rsp]
	mov	DWORD PTR [rax+4], ecx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\james\source\repos\berconmaps\src\noise.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

; 221  : }

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR __f$[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
